- Get rid of ttyout.[ch], the only thing it exists for is for userspace printf
to print to console.  They should do this through the stdout fd anyway - and
the important things from ttyout (i.e. the serial sending etc) should (and I
think, are?) in network.[ch].  This would fix the hack that is the message
contents being sent through the IPC.  It should be through the write sycall.

- Speaking of this, set up stdin/out/err.  The cleanest way to do this would
be to change the way threads are being created - at the moment it's through
L4_ThreadControl in libsos.c, telling L4 to create a thread directly in the
function.  Rather - we should have some kind of generic init thread function
which threads should always start in, which sets up the file descriptors (and
maybe some other stuff later - who knows) and then calls the real main function
which it would be passed somehow.

- Okay, so it isn't trivial to do what I mentioned above.  What it probably
involves is to use the ExchangeRegisters system call to change the value of the
IP once the thread has started.  So something like:
	- Instead of starting at the real IP, start in a generic thread_init function
	  to set up the address space (i.e. open file pointers etc).
	- thread_init does some kind of IPC to signal to SOS that it's finished.
	- SOS uses L4_ExchangeRegisters to change the value of the IP.  Or hmmm maybe
	  it would just be enough to use the L4_Start_SpIp.

- Use sender2kernel for EVERY userspace pointer dereference.  It would be nice
to get the *complier* to actually enforce some kind of safety with that, but
given this is C we'll probably just have to enforce it ourselves.  Perhaps wrap
in some kind of struct e.g.
	typedef struct {
		void *ptr;
	} userptr;
then sender2kernel would be something like:
	void *sender2kernel(userptr p);
could get slightly messy syntactially (e.g. would need a way to get pointer
offsets, easy through wrapper function) but I think it's a good idea given how
"unsafe" it is.  Well, it's probably not unsafe in practice, just in theory.

- As part of the above point, any time sender2kernel is used we should check
it doesn't return NULL.  And fail nicely (from the kernel's perspective) if
it does.  Should kill thread though.

- Also as part of the sender2kernel point, there needs to be some way to check
the access rights of the regions.  This is because the kernel has write access
to everything (see frames.c) so if the user process is devious it could trick
the kernel in to writing over a read-only region (eg. the code/data).  Strictly
speaking this isn't actually a problem right now, because the code/data regions
aren't mapped by the frame table, only on a page fault (see doPager in pager.c)
and at that point they are mapped even for the kernel with the correct rights.
However, it would be nice to fix this as long as it's not too messy.  I can see
two ways to fix: either remap anything from the frame table with the correct
access rights, or add a flag to sender2kernel that checks the access rights of
the region before doing anything.  A clean way to do this would be to include
that flag in the userptr struct.  However - I think the former option is
probably nicer.
L4_UncachedMemory.

- Milestone 4 - the NFS stuff seems pretty straightforward, maybe 1 or 2 days
of work (once some of the above issues have been fixed).

- Pager can call pager via malloc!  We haven't noticed this bug because we havent
tested for it.  But basically, since it's a 2 level page table, if the malloc used
to create the 2nd level causes morecore to be called, the region will be extended,
the pager will try to access that region, then it will page fault.  Kaboom.

- There are a lot of potential bugs when we have demand paging.  Be vigilant :-)

- Milestone 6 - we have until week 8, hooray.

- Testing.  Jesus we need to do more testing.

- Timer driver seems to be a bit slow for some reason, compared to the Linux
sleep at least.  Could be hardware/software on either side, or could be bug.

- VFS needs a lot of commenting! none at moment and complicated interfaces and
calling conventions.

- VFS could use a general beauty clean

- VFS could return better errors then just -1, actually indicate the error
reason to user space.

- Investigate moving the sync request code into the vfs layer rather then fs.

- Move MaxReader, MaxWriter and the reader, writer counters out of consolefs
into the vfs and then handle opening already open vnodes in the vfs layer
instead of having each fs handle it

- NFS, when writing to a new file, do we need to truncate it first? If not
we really just overwrite data, so 'cp' for example doesn't work as
expected but I think this might be a libc and also a syscall api
problem.

- loop bug with NFS request list struct
